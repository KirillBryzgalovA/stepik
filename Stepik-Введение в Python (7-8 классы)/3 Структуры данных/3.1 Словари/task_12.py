'''
Список книг на лето
    Этим летом местная библиотека неожиданно столкнулась с потоком школьников, желающих взять некоторые книги из списка литературы. Чтобы не нагружать своих работников, руководство библиотеки решило создать электронную систему учета книг, которая бы показывала, какие книги есть в наличии. В библиотеке провели ревизию и записали в систему все книги. Когда очередной школьник пытается взять книгу, библиотекарь сначала проверяет, есть ли она в наличии. Если есть, книга временно удаляется из системы. У школьника есть один месяц, чтобы вернуть книгу. Вам поручили написать данную систему и протестировать ее на наборе смоделированных записей. Будем считать, что если школьник не вернул книгу в течение месяца, коллекторы, нанятые руководителем библиотеки, в день истечения срока самостоятельно изымают книгу.

    Формат ввода: программе сначала передается список книг через запятую, затем строки, описывающие поведение посетителей: строка вида "Взять <книга> <дата> (<имя>)" или "Вернуть <книга> <дата>". Ввод происходит до точки. Заметьте, что руководство библиотеки решило усложнить Вам задачу, и записи передаются не в хронологическом порядке.

    Формат вывода: после того, как посетитель взял книгу, необходимо вывести "Книгу <книга> забрал(а) <имя>". Если данной книги нет, выведите "Книга <книга> отсутствует. Ее забрал(а) <имя>".

  Примечание: если школьник взял книгу k-го числа n-го месяца, то гарантируется, что k-ый день (n + 1)-го месяца - это корректная дата.
'''


def decomposition(s: str):
    ind_1 = s.find('"')
    ind_2 = s.rfind('"')
    take = s[0:ind_1].strip()
    book = s[ind_1:ind_2 + 1]
    ind_3 = s.find('(')
    if ind_3 != -1:
        date_book_lst = s[ind_2 + 1:ind_3].strip().split('.')
    else:
        date_book_lst = s[ind_2 + 1:ind_2 + 12].strip().split('.')
    # date_book = datetime.date(int(date_book_lst[2]), int(date_book_lst[1]), int(date_book_lst[0]))
    # переведем дату в вид  день + месяц * 30 + год * 360.
    date_book = int(date_book_lst[0]) + int(date_book_lst[1]) * 30 + int(date_book_lst[2]) * 360
    if ind_3 == -1:  # если вернуть книгу
        people = ''
    else:
        people = s[ind_3 + 1:s.rfind(')')]

    return [take, book, date_book, people]


# хранение запросов в хронологическом порядке
def save_question():
    pass


#######################################################################################

lst_books = [book.strip() for book in input().split(',')]

# хранение книг
dict_books = dict.fromkeys(lst_books, [])
lst_question = []

# загрузка вопросов в неотсортированном порядке
while True:
    s = input()
    if s == '.':
        break
    lst = decomposition(s)
    lst_question.append(lst)

# сортируем запросы в порядке возрастания времени
lst_sort = sorted(lst_question, key=lambda item: item[2])
# lst_sort [['Взять', '"Оно"', 727073, 'Джейн'], ['Взять', '"Честь имею"', 727083, 'Карл']]
# {"Название книги": ["Имя читателя", дата], "Название книги2": []}
# print(lst_sort)
# пробегаем по запросам (уже сортированным)
for question in lst_sort:
    if question[0] == 'Взять':
        # проверка не прошел ли 1 месяц со дня выдачи книги
        # дата выдачи больше 1 месяца даты выдачи книги предыдущему ученику или ее никто не брал
        if dict_books.get(question[1]) == [] or question[2] - dict_books[question[1]][1] >= 30:
            dict_books[question[1]] = [question[3], question[2]]  # заносим в словарь
            print(f"Книгу {question[1]} забрал(а) {question[3]}")
        else:
            print(f"Книга {question[1]} отсутствует. Ее забрал(а) {dict_books[question[1]][0]}")
    if question[0] == 'Вернуть':
        dict_books[question[1]] = []  # книга опять в библиотеке
